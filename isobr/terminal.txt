Регулярные выражения

. - означает один символ

[]- один символ и некого множества.
  [a-z]- диапозон(все маленькие буквы английского алфавита), в данном случае одна маленькая буква английского алфавита
  [a-zA-Z]-диапозон(все буквы английского алфавита), одна ил букв английского алфавита
  [a-zA-Z0-9]-диапозон(все буквы английского алфавита и цифры.)
  [^a-z]-означает все символы,КРОМЕ маленьких укв английского алфавита.

Повторители
* - любое количество  символов:  .*- означает любое количество любых символов
+ - один или более:  s+ - означает одну или более букву s
? - ноль или один
{m} - Ровно m повторений
{m,n} - от m до n повторений:  .{5,7}-означает любой символ от 5 до 7 раз встречающийся.
                              [a-zA-Z]{5,7} - от 5 до 7 букв английского алфавита.

Именованные регулярные выражение
\(выражение\) \1
\(.\)\1\1 - повторение три раза одного и тогоже символа.

команды работе в Шэле

cat t.c - распечатка содержимого файла t.c на экран.
head t.c - распечатка первых 10 строк файла t.c.
tail t.c - распечатка последник 10 строк файла t.c.
Можно также перенаправлять потоки вывода, например команда
cat t.c > tt.txt произведет распечатку файла t.c не на экран, а в файл tt.txt
cat t.c > tt.txt 2>err.txt - во первых, как и ранее мы перенаправляем поток вывода данных, а затем
 командой 2>err.txt мы перенаправляем вывод ошибок программы.
 more - просмотр файла с возможностью пролиствать данные.
  gcc t.c 2>>err.txt - теперь иы не просто переводим направление вывода, но и говорим, чтобы
  данные подклеились к данным, ранее записанным в файле.
  Аналогичным способом мы можем говорить и о перенаправлении ввода , например нам нужно
  ввести множество данных, и нам не удобно это сделать из терминала, поэтому мы можем
  написать <имя файла - что будет расценено как перенаправления места, откуда считывать
  данные.

 конвеер - |
cat t.c | cat - мы передаем стандартный поток вывода программы cat t.c на поток ввода второй программы,
а так как вторая программа cat не имеет имени файла, то она просто считает все данные, которые
пришли к нему по стандартному потоку ввода, который есть поток вывода cat t.c ,и передаст это
стандартному потоку вывода второй программы, то есть на экран.

Есть команда date, которая на стандартный поток вывода выводит текущее время .
Можно попросить, чтобы команда date выдовала бы данные в определенном формате,
например date +'arch-%d-%m-%y'на выходе получим arch-04-01-21

zip - команда создания архива.

оператор обратные ковычки ``,позвляет при работе в командной строке вставить на веделенное место
поток вывода записанной в ковычках команды
например при записи команды
--- `date +'arch-%d-%m-%y'` -- внутримковычек вставится запись arch-04-01-21 и реально
будет выполнена команда
--- arch-04-01-21 --

Например zip `date +'arch-%d-%m-%y'` * - * в этой строке обозначает следующее,
сначала , перед вызовом соответсвенной команды zip, произойет обработка подаваемых в нее
данных с помощью интерпретатора, и только после этого обработынные данные пойдут к команде,
* означает- что нет никакого ограничения на имена файлов.

Есть командочка echo которая выведет,какая на самом деле команда будет вызвана после
работы интерпретатора , например,
echo zip `date +'arch-%d-%m-%y'` *
zip arch-04-01-21 arch-04-01-21.zip prog1 prog2 prog3 prog4 sort terminal.txt tt.txt -вот что на самом деле будет вызвано
в команной строке после работы интерпретатора .

Если мы напишем zip `date +'arch-%d-%m-%y'` *.c - теперь речь пойдет только о файлах,
которые имеют расширение ****.с . то есть все что угодно до "." , а после нее должен стоять один символ "с".

Есди мы напишем zip `date +'arch-%d-%m-%y'` ?.c то это уже все файлы, такие, что до "." у них стоит
любой один символ, а после точки стоит буква "с".

Есди мы напишем zip `date +'arch-%d-%m-%y'` ?.? - то это будут рассмотрены все файлы,
такие что их имя представляется в виде (один символ).(один символ)

 Можно создать две переменные
 i=1
 q=mama
 обращение к ним через $
 $i интерпретатором заменяется на 1
 echo $i -> 1
 echo $q -> mama
  экранирование
      Что вообще предвещает этому термину? допустим мы захотели выписать какой-то набор символов
      просто как набор символов, а не как какую-то команду, и понятна в чем проблема, если в
      этом наборе символов появляются какие-то специальные символы, которые обрабатываются
      интепретатором по своему, например аналог из С, вы хотите вывести на экран "\n", но если вы
      напишите printf("\n"), то вы получите совершенно не желаем результат(сдвиг строки), поэтому
      нужно как-то пояснить, что вы используете это не как какой-то специальный элемент(управляющую последовательность),
      а как просто набор символов, это можно сделать так printf("\\n");
      так и в терминале \ означает , что последующий символ не поддается обработки интерпретаторов,
      как особый символ, то есть для него это просто обычный символ, такое действие и называется
      экранированием.
  echo \{$i\}
   ii=2
 можно с помощь фигурных скобок отделять,какие именно части текста мы экранируем ,
 как название переменных, а какие просто как набор симвоов.

 echo $ii будет понято, как выполнение echo  к значению переменной ii, поэтому просто будет вывод ее значения
 ->2
 echo ${i}i будет работать так, вместо ${i} будет подставлено значение переменной i, а потом уже к этому вызван echo
      |
 echo 1i
 -> 1i

  так же есть экранирование с помощью '', будет полное экранирование всего, что между ними
  echo '\{$i\}'
 -> \{$i\}
  а ""-работает иначе, все что стоит между ними заменяется в одно слово, но возможна замена
   переменных на их значения
   echo "\{$i\}"
 -> \{1\}

 так же возможны циклы, а именно
 for i in (список перебираемых объектов); do echo $i ; done;
 Например,
 for i in 1 2 3 4; do echo $i ; done
 ->1
 ->2
 ->3
 ->4

 можно написать также
 for i in *; do echo $i ; done;
 такая запись будет означать, что в качестве перебираемого элемента будут использоваться
 все файлы данной директории, а это значит, что с каждым из них я могу что-то сделать

 Так же есть С-подобная запись этого цикла.
 for((i=0;i<10;i++)) ; do echo $i ;done

 Возможно использовать арифметические и логические выражения
 Например с помощью команды
 expr 1 + 2 + 3 с помощью команды
ВАЖНО!!! Все слова должны быть отделены между собой пробелами.

А есть еще один вариант выполнения арифметических выражений
echo $[ 1 + 2 + 3 ]  с помощью интерпритатора командой строки
ВАЖНО!!! Все слова должны быть отделены между собой пробелами.

логическое выражение
[[ 1 -lt 2 ]] Арифметические операции пишутся буквами!!!
ВАЖНО!!! Все слова должны быть отделены между собой пробелами.

 Давайте теперь создадим  кмандный файл, то есть файл, в котором прописан набор команд на вылонение, по типу
 Makefile, но только заранее нужно будет дать этому файлу права на исполнение, чтобы мы могли его запустить.

 делается это так, создается обычный файл без расширения, а затем даются ему права на исполнение следующей
 командой
 chmod a+x s
 теперь это файл можно выполнять
 ./s

 Поиск имен файлов
whereis- ищет файл среди стандартных папок.
 whereis stdio.h
 locate - немного усложненый поиск, показывает все файлы, в имени которых встречался
 запрошенный нами текст, ищет он по какой-то своей внутренней базе данных.
find начинает искать начиная с какой-то папки.
 find/usr/include - name stdio.h -print

 Потоковые редакторы

  grep n s - по умолчанию он выводит имя файла(если таковых много) и стору, в которой встречается данный
  символ, при выводе этой строки она меняет цвет этоко символа для его выделения.

  можно писать по иному
  grep -c a *
  ключ -с говорит о том, чтобы программа вывдила не сами строки , в которых встречались элементы,
  а выводила имена файлов и количество повторений нашего символа в нем

  prep -i a *
  ключ -i говорит о том, что будут рассмотриваться и маленькие и большие буквы.
  Маленькие и большие считаются одинаковыми.

  А что если мы хотим вывести только переменные с названием "a" , это значит, что в качестве
  шаблона указать, что это такая буква, перед и помле которой не стоит ни буква, ни символ подчеркивания
  grep '[^a-zA-Z0-9_]a[^a-zA-Z0-9_]' *


  sed-изменяет или как-то модифицирует строки , подоваемые в неё из  файла.
  sed 's/Выражение1/выражение 2/' - заменяет в строке выражение 1 на выражение 2, но делает он это только
  один раз,
  если напишем sed 's/Выражение1/выражение 2/g'- то произойдет глобальная замена, то есть замена во всей строке.

  Давайте изменим имя переменной,сделать это можно так.
  cat t.c | sed 's/\([^a-zA-Z0-9_]\)a\([^a-zA-Z0-9_]\)/\1X\2/g'
  Но заметим, что мы должны поменять выражения не просто на Х, а на Х и то же набор
  окружающих его символов, поэтому мы воспользуемся именными выражениями, которые как мы говорили
  создают имена \1 и \2, теперь действительно изменятся названия самих переменных,
  только вот на самом деле они не изменятся в файле, а просто модифицируется вывод cat

  cat t.c | sed 's/\([^a-zA-Z0-9_]\)a\([^a-zA-Z0-9_]\)/\1X\2/g' >t2.c
  такая запись выведет его уже в файл t2.c

  переименование файлов

  for x in *.c ; do mv $x ${x}pp ; done
  Данный цикл все файлы с расширением c заменит на файлы с расширением cpp.
  for x in *.cpp ; do echo mv $x `echo $x | sed 's/pp$//'`;done
  Данный цикл все файлы с расширением cpp заменит на файлы с расширением c.

  ^  в начале шаблоны означает начало строки, а $ в конце шаблона = конец строки.

  Давайте на примере посмотрим , как работает АВК
     cat q.q
  -> 1 2 3 4
  -> 5 6 7 8
  -> 11 12 13 14
     cat q.q | awk '{print $2}' -выводит второй столбец
  ->2
  ->6
  ->12

 Значит awk построчно ест все с потока ввода, строку она разбивает на поля, которые нумеруются
 начиная с 1, к этим полям можно обращаться, когда мы пишем '{здесь написана программа того, что надо сделать}'
 шаблон писался бы иначе '//'


 cat q.q | awk '{for(i=1;i<NF;i++)if(i!=2)print $i;else print $i+1}'  NF количество  полей в строке print ставит в конце переход на след строку.
->1
->3
->3
->5
->7
->7
->11
->13
->13

cat q.q | awk '{for(i=1;i<=NF;i++)if(i!=2)printf("%d ",$i);else printf("%d ",$i+1); printf("\n")}'
1 3 3 4
5 7 7 8
11 13 13 14
